/******************************************************
 * Behavior implementation file template.             *
 * This file is automatically generated by ArchC      *
 * WITHOUT WARRANTY OF ANY KIND, either express       *
 * or implied.                                        *
 * For more information on ArchC, please visit:       *
 * http://www.archc.org                               *
 *                                                    *
 * The ArchC Team                                     *
 * Computer Systems Laboratory (LSC)                  *
 * IC-UNICAMP                                         *
 * http://www.lsc.ic.unicamp.br                       *
 ******************************************************/

/**
 * @file   msp430_isa.cpp
 * @author Rogerio Paludo <rogerio.pld@gmail.com>
 * @date   Thu Jan 29 22:29:20 2015
 * 
 * @brief  In this is file is implemented all the instructions behavior
 * 
 * @todo Testing
 */

#include  "msp430_isa.H"
#include  "msp430_isa_init.cpp"
#include  "msp430_bhv_macros.H"
#include  "msp430_global.cpp"
#include  "methdoins.cpp"
#include <unistd.h>


/// 'using namespace' statement to allow access to all msp430-specific datatypes
using namespace msp430_parms;

//********************************************************************
// Methods
//********************************************************************
/** 
 * This function is called when there is a constant involved 
 * 
 * @param sreg source register
 * @param as addressing field used for the source
 * @param constant structure constant (contains value and mode)
 * 
 * @return a structure cnt
 */
inline cnt Const(int sreg, int as, cnt constant) {	
  if (sreg == SR && (as == 2 || as == 3) || sreg == 3) {
    constant.mode = true;		
    switch (as) {
    case 0: if (sreg == 3) constant.value = 0; break;
    case 1: if (sreg == 3) constant.value = 1; break;
    case 2: constant.value = ((sreg == 3) ? 2 : 4); break;
    case 3: constant.value = ((sreg == 3) ? -1 : 8); break;
    }
  }
  return constant;	
}
//********************************************************************
// Behavior
//********************************************************************
//!Behavior executed before simulation begins.
void ac_behavior( begin ){
  //  printf("Please enter the start address of the instruction memory\n");
  //  uint16_t address;
  //  cin >> hex >> address;
  RB.write(PC, 0x1100);
  RB.write(SR, 0);
};

//!Behavior executed after simulation ends.
void ac_behavior( end ){};

//!Generic instruction behavior method.
void ac_behavior( instruction ){
  dbg_printf("----- PC=%#x ----- %lld\n", (int) RB.read(PC), ac_instr_counter);	
  dbg_printf("size: %u \n", get_size());
	
  // Update flags from status register
  flags.N = (RB.read(SR) & 0x4) ? true : false;
  flags.Z = (RB.read(SR) & 0x2) ? true : false;
  flags.C = (RB.read(SR) & 0x1) ? true : false;
  flags.V = (RB.read(SR) & 0x100) ? true : false;  
  dbg_printf("----- SR=0x%X ----- \n", RB.read(SR)); 

  // Test CPUOFF bit
  if (getBit(RB.read(SR), 4)) {
    dbg_printf("CPUOFF bit 0x%X\n", getBit(RB.read(SR), 4));
    stop();
  }
};
 
// Instruction Format behavior methods.

// ******************DOUBLE******************
/// 48 bits double operand instruction generic behavior
void ac_behavior( Double_48 ){
  dbg_printf("inst:-> %s op:%d, sreg:%d, ad:%d, bw:%d, as:%d, dreg:%d, osrc:0x%X, odst:0x%X\n",
	     get_name(), op, sreg, ad, bw, as, dreg, osrc, odst);

  // Constant generator
  constant = Const(sreg, as, constant);
 
  // Update Program Counter
  // conditional increment
  if (constant.mode) {
    RB.write(PC, RB.read(PC) + 4);
    ac_pc = RB.read(PC);
  } else {
    RB.write(PC, RB.read(PC) + get_size());
    ac_pc = RB.read(PC);
  }
}
/// 32 bits double operand instruction generic behavior
void ac_behavior( Double_32 ){
  dbg_printf("inst:-> %s op:%d, sreg:%d, ad:%d, bw:%d, as:%d, dreg:%d, oset:0x%X\n",
	     get_name(), op, sreg, ad, bw, as, dreg, oset);
  
  // Constant generator
  constant = Const(sreg, as, constant);	

  // Update Program Counter
  // conditional increment
  if (constant.mode && ad == 0) {
    RB.write(PC, RB.read(PC) + 2);
    ac_pc = RB.read(PC);
  } else {
    RB.write(PC, RB.read(PC) + get_size());
    ac_pc = RB.read(PC);
  }
}
/// 16 bits double operand instruction generic behavior
void ac_behavior( Double ){
  dbg_printf("inst:-> %s op:%d, sreg:%d, ad:%d, bw:%d, as:%d, dreg:%d\n",
	     get_name(), op, sreg, ad, bw, as, dreg);
  // Constant generator
  constant = Const(sreg, as, constant);	
	
  // update PC
  RB.write(PC, RB.read(PC) + get_size());
  ac_pc = RB.read(PC);
}

// ******************SINGLE******************
///  32 bits single operand instruction generic behavior
void ac_behavior( Single_32 ){
  dbg_printf("inst:-> %s op:%d, bw:%d, as:%d, sreg:%d, oset:0x%X\n",
	     get_name(), op, bw, as, sreg, oset);
	
	// Constant generator
  constant = Const(sreg, as, constant);	

  // update PC
  RB.write(PC, RB.read(PC) + get_size());
  ac_pc = RB.read(PC);
}
/// 16 bits single operand instruction generic behavior
void ac_behavior( Single ){
  dbg_printf("inst:-> %s op:%d, bw:%d, as:%d, sreg:%d\n",
     get_name(), op, bw, as, sreg);

	// Constant generator
  constant = Const(sreg, as, constant);	
	
  // update PC
  RB.write(PC, RB.read(PC) + get_size());
  ac_pc = RB.read(PC);
}

// ******************JUMP******************
/// Jump instruction generic behavior
void ac_behavior( Jump ){
  dbg_printf("inst:-> %s op:%d, c:%d, offset:%d\n",
	     get_name(), opc, c, offset);
	
  // update PC
  RB.write(PC, RB.read(PC) + get_size());
  ac_pc = RB.read(PC);
}

//*****************************************************
// Instructions
//*****************************************************

/**
 * 
 * @defgroup DOUBLE DOUBLE operand instructions 
 * 
 * @brief All the double operand instruction 
 * @{ 
 */
//*****************************************************
// Double
//*****************************************************

/**
 * 
 * @defgroup MOV MOV instruction 
 * 
 * @brief group for all addressing modes
 * @{ 
 */
//!Instruction mov_16rm behavior method.
void ac_behavior( mov_16rm ){
  mode = _16rm;
  MOV(sreg, bw, as, dreg, 0, 0, 0, DM, RB, ac_pc);
}

//!Instruction mov_16irm behavior method.
void ac_behavior( mov_16irm ){
  mode = _16irm;
  MOV(sreg, bw, as, dreg, 0, 0, 0, DM, RB, ac_pc);
}

//!Instruction mov_16iaim behavior method.
void ac_behavior( mov_16iaim ){
  mode = _16iaim;
  MOV(sreg, bw, as, dreg, 0, 0, 0, DM, RB, ac_pc);
}

//!Instruction mov_32idst behavior method.
void ac_behavior( mov_32idst ){
  mode = _32idst;
	 if (dreg != 2) 
    oset = (uint16_t)(oset + RB.read(dreg));
  MOV(sreg, bw, as, dreg, oset, 0, 0, DM, RB, ac_pc);
}

//!Instruction mov_32isrc behavior method.
void ac_behavior( mov_32isrc ){
  mode = _32isrc;
  if (sreg != 2) 
    oset = (uint16_t)(oset + RB.read(sreg));
  MOV(sreg, bw, as, dreg, oset, 0, 0, DM, RB, ac_pc);
}

//!Instruction mov_32imm behavior method.
void ac_behavior( mov_32imm ){
  mode = _32imm;
  MOV(sreg, bw, as, dreg, oset, 0, 0, DM, RB, ac_pc);
}

//!Instruction mov_32iaim behavior method.
void ac_behavior( mov_32iaim ){
  mode = _32iaim;
  if (dreg != 2)
    oset = (uint16_t)(oset + RB.read(dreg));
  MOV(sreg, bw, as, dreg, oset, 0, 0, DM, RB, ac_pc);
}

//!Instruction mov_32irm behavior method.
void ac_behavior( mov_32irm ){
  mode = _32irm;
  if (dreg != 2)
    oset = (uint16_t)(oset + RB.read(dreg));
  MOV(sreg, bw, as, dreg, oset, 0, 0, DM, RB, ac_pc);
}

//!Instruction mov_48idm behavior method.
void ac_behavior( mov_48idm ){
  mode = _48idm;
  if ((sreg != SR && dreg != SR)) {// then we are using indexed mode
    if (constant.mode) 
      odst = (uint16_t)(osrc + RB.read(dreg));
    else {
      odst = (uint16_t)(odst + RB.read(dreg));
      osrc = (uint16_t)(osrc + RB.read(sreg));
    }
  }
  if (constant.mode && dreg == SR)
    odst = (uint16_t)(osrc);

  MOV(sreg, bw, as, dreg, 0, osrc, odst, DM, RB, ac_pc);  
}

//!Instruction mov_48imm behavior method.
void ac_behavior( mov_48imm ){
  mode = _48imm;
  if (dreg != 2)
    odst = (uint16_t)(odst + RB.read(dreg));
  MOV(sreg, bw, as, dreg, 0, osrc, odst, DM, RB, ac_pc);
}
//@}

/**
 * 
 * @defgroup ADD ADD instruction 
 * 
 * @brief group for all addressing modes
 * @{ 
 */
//****************** ADD ***********************
//!Instruction add_16rm behavior method.
void ac_behavior( add_16rm ){
  mode = _16rm;
  ADD(sreg, bw, dreg, 0, 0, 0, DM, RB, RB.read(sreg), RB.read(dreg));
}

//!Instruction add_16irm behavior method.
void ac_behavior( add_16irm ){
  mode = _16irm;
  ADD(sreg, bw, dreg, 0, 0, 0, DM, RB, DM.read(RB.read(sreg)), RB.read(dreg));
}

//!Instruction add_16iaim behavior method.
void ac_behavior( add_16iaim ){
  mode = _16iaim;
  ADD(sreg, bw, dreg, 0, 0, 0, DM, RB, DM.read(RB.read(sreg)), RB.read(dreg));
}

//!Instruction add_32idst behavior method.
void ac_behavior( add_32idst ){
  mode = _32idst;
  if (dreg != 2)
    oset = (uint16_t)(oset + RB.read(dreg));
  ADD(sreg, bw, dreg, oset, 0, 0, DM, RB, RB.read(sreg), DM.read(oset));
}

//!Instruction add_32isrc behavior method.
void ac_behavior( add_32isrc ){
  mode = _32isrc;
   if (sreg != 2) // then whe are not in the absolute mode for source
    oset = (uint16_t)(oset + RB.read(sreg));
   dbg_printf("oset: 0x%X \n", (uint16_t)oset);
  ADD(sreg, bw, dreg, oset, 0, 0, DM, RB, DM.read(oset), RB.read(dreg));
}

//!Instruction add_32imm behavior method.
void ac_behavior( add_32imm ){
  mode = _32imm;
  ADD(sreg, bw, dreg, oset, 0, 0, DM, RB, oset, RB.read(dreg));
}

//!Instruction add_32iaim behavior method.
void ac_behavior( add_32iaim ){
  mode = _32iaim;
   if (dreg != 2)
     oset = (uint16_t)(oset + RB.read(dreg));
  ADD(sreg, bw, dreg, oset, 0, 0, DM, RB, DM.read(RB.read(sreg)), DM.read(oset));
}

//!Instruction add_32irm behavior method.
void ac_behavior( add_32irm ){
  mode = _32irm;
  if (dreg != 2)
    oset = (uint16_t)(oset + RB.read(dreg));
  ADD(sreg, bw, dreg, oset, 0, 0, DM, RB, DM.read(RB.read(sreg)), DM.read(oset));
}

//!Instruction add_48idm behavior method.
void ac_behavior( add_48idm ) {
  mode = _48idm;
  if ((sreg != SR && dreg != SR)) {// then we are using indexed mode
    if (constant.mode) 
      odst = (uint16_t)(osrc + RB.read(dreg));
    else {
      odst = (uint16_t)(odst + RB.read(dreg));
      osrc = (uint16_t)(osrc + RB.read(sreg));
    }
  }
  if (constant.mode && dreg == SR)
    odst = (uint16_t)(osrc);

  ADD(sreg, bw, dreg, 0, osrc, odst, DM, RB, DM.read(osrc), DM.read(odst));  
}

//!Instruction add_48imm behavior method.
void ac_behavior( add_48imm ){
  mode = _48imm;
  if (dreg != 2)
    odst = (uint16_t)(odst + RB.read(dreg));
  ADD(sreg, bw, dreg, 0, osrc, odst, DM, RB, osrc, DM.read(odst));
}
//@}

/**
 * 
 * @defgroup ADDC ADDC instruction 
 * 
 * @brief group for all addressing modes
 * @{ 
 */
//****************** ADDC ************************
//!Instruction addc_16rm behavior method.
void ac_behavior( addc_16rm ){
  mode = _16rm;
  ADDC(sreg, bw, dreg, 0, 0, 0, DM, RB, RB.read(sreg), RB.read(dreg));
}

//!Instruction addc_16irm behavior method.
void ac_behavior( addc_16irm ){
  mode = _16irm;
  ADDC(sreg, bw, dreg, 0, 0, 0, DM, RB, DM.read(RB.read(sreg)), RB.read(dreg));
}

//!Instruction addc_16iaim behavior method.
void ac_behavior( addc_16iaim ){
  mode = _16iaim;
  ADDC(sreg, bw, dreg, 0, 0, 0, DM, RB, DM.read(RB.read(sreg)), RB.read(dreg));
}

//!Instruction addc_32idst behavior method.
void ac_behavior( addc_32idst ){
  mode = _32idst;
	if (dreg != 2)
    oset = (uint16_t)(oset + RB.read(dreg));
  ADDC(sreg, bw, dreg, oset, 0, 0, DM, RB, RB.read(sreg), DM.read(oset));
}

//!Instruction addc_32isrc behavior method.
void ac_behavior( addc_32isrc ){
  mode = _32isrc;
	 if (sreg != 2) // then whe are not in the absolute mode for source
    oset = (uint16_t)(oset + RB.read(sreg));
  ADDC(sreg, bw, dreg, oset, 0, 0, DM, RB, DM.read(oset), RB.read(dreg));
}

//!Instruction addc_32imm behavior method.
void ac_behavior( addc_32imm ){
  mode = _32imm;
  ADDC(sreg, bw, dreg, oset, 0, 0, DM, RB, oset, RB.read(dreg));
}

//!Instruction addc_32iaim behavior method.
void ac_behavior( addc_32iaim ){
  mode = _32iaim;
	if (dreg != 2)
     oset = (uint16_t)(oset + RB.read(dreg));
  ADDC(sreg, bw, dreg, oset, 0, 0, DM, RB, DM.read(RB.read(sreg)), DM.read(oset));
}

//!Instruction addc_32irm behavior method.
void ac_behavior( addc_32irm ){
  mode = _32irm;
	 if (dreg != 2)
    oset = (uint16_t)(oset + RB.read(dreg));
  ADDC(sreg, bw, dreg, oset, 0, 0, DM, RB, DM.read(RB.read(sreg)), DM.read(oset));
}

//!Instruction addc_48idm behavior method.
void ac_behavior( addc_48idm ){
  mode = _48idm;
  if ((sreg != SR && dreg != SR)) {// then we are using indexed mode
    if (constant.mode) 
      odst = (uint16_t)(osrc + RB.read(dreg));
    else {
      odst = (uint16_t)(odst + RB.read(dreg));
      osrc = (uint16_t)(osrc + RB.read(sreg));
    }
  }
  
  if (constant.mode && dreg == SR)
    odst = (uint16_t)(osrc);
  
  ADDC(sreg, bw, dreg, 0, osrc, odst, DM, RB, DM.read(osrc), DM.read(odst));
}

//!Instruction addc_48imm behavior method.
void ac_behavior( addc_48imm ){
  mode = _48imm;
	 if (dreg != 2)
    odst = (uint16_t)(odst + RB.read(dreg));
  ADDC(sreg, bw, dreg, 0, osrc, odst, DM, RB, osrc, DM.read(odst));
}
//@}

/**
 * 
 * @defgroup AND AND instruction 
 * 
 * @brief group for all addressing modes
 * @{ 
 */
//****************** AND ************************
//!Instruction and_16rm behavior method.
void ac_behavior( and_16rm ){
  mode = _16rm;
  AND(sreg, bw, dreg, 0, 0, 0, DM, RB, RB.read(sreg), RB.read(dreg));
}

//!Instruction and_16irm behavior method.
void ac_behavior( and_16irm ){
  mode = _16irm;
  AND(sreg, bw, dreg, 0, 0, 0, DM, RB, DM.read(RB.read(sreg)), RB.read(dreg));
}

//!Instruction and_16iaim behavior method.
void ac_behavior( and_16iaim ){
  mode = _16iaim;
  AND(sreg, bw, dreg, 0, 0, 0, DM, RB, DM.read(RB.read(sreg)), RB.read(dreg));
}

//!Instruction and_32idst behavior method.
void ac_behavior( and_32idst ){
  mode = _32idst;
		if (dreg != 2)
    oset = (uint16_t)(oset + RB.read(dreg));
  AND(sreg, bw, dreg, oset, 0, 0, DM, RB, RB.read(sreg), DM.read(oset));
}

//!Instruction and_32isrc behavior method.
void ac_behavior( and_32isrc ){
  mode = _32isrc;
	 if (sreg != 2) // then whe are not in the absolute mode for source
    oset = (uint16_t)(oset + RB.read(sreg));
  AND(sreg, bw, dreg, oset, 0, 0, DM, RB, DM.read(oset), RB.read(dreg));
}

//!Instruction and_32imm behavior method.
void ac_behavior( and_32imm ){
  mode = _32imm;
  AND(sreg, bw, dreg, oset, 0, 0, DM, RB, oset, RB.read(dreg));
}

//!Instruction and_32iaim behavior method.
void ac_behavior( and_32iaim ){
  mode = _32iaim;
	if (dreg != 2)
     oset = (uint16_t)(oset + RB.read(dreg));
  AND(sreg, bw, dreg, oset, 0, 0, DM, RB, DM.read(RB.read(sreg)), DM.read(oset));
}

//!Instruction and_32irm behavior method.
void ac_behavior( and_32irm ){
  mode = _32irm;
	if (dreg != 2)
    oset = (uint16_t)(oset + RB.read(dreg));
  AND(sreg, bw, dreg, oset, 0, 0, DM, RB, DM.read(RB.read(sreg)), DM.read(oset));
}

//!Instruction and_48idm behavior method.
void ac_behavior( and_48idm ){
  mode = _48idm;
  if ((sreg != SR && dreg != SR)) {// then we are using indexed mode
    if (constant.mode) 
      odst = (uint16_t)(osrc + RB.read(dreg));
    else {
      odst = (uint16_t)(odst + RB.read(dreg));
      osrc = (uint16_t)(osrc + RB.read(sreg));
    }
  }

  if (constant.mode && dreg == SR)
    odst = (uint16_t)(osrc);
  
  AND(sreg, bw, dreg, 0, osrc, odst, DM, RB, DM.read(osrc), DM.read(odst));
}

//!Instruction and_48imm behavior method.
void ac_behavior( and_48imm ){
  mode = _48imm;
	 if (dreg != 2)
    odst = (uint16_t)(odst + RB.read(dreg));
  AND(sreg, bw, dreg, 0, osrc, odst, DM, RB, osrc, DM.read(odst));
}
//@}

/**
 * 
 * @defgroup BIC BIC instruction 
 * 
 * @brief group for all addressing modes
 * @{ 
 */
//****************** BIC ************************
//!Instruction bic_16rm behavior method.
void ac_behavior( bic_16rm ){
  mode = _16rm;
  BIC(sreg, bw, dreg, 0, 0, 0, DM, RB, RB.read(sreg), RB.read(dreg));
}

//!Instruction bic_16irm behavior method.
void ac_behavior( bic_16irm ){
  mode = _16irm;
  BIC(sreg, bw, dreg, 0, 0, 0, DM, RB, DM.read(RB.read(sreg)), RB.read(dreg));
}

//!Instruction bic_16iaim behavior method.
void ac_behavior( bic_16iaim ){
  mode = _16iaim;
  BIC(sreg, bw, dreg, 0, 0, 0, DM, RB, DM.read(RB.read(sreg)), RB.read(dreg));
}

//!Instruction bic_32idst behavior method.
void ac_behavior( bic_32idst ){
  mode = _32idst;
		if (dreg != 2)
    oset = (uint16_t)(oset + RB.read(dreg));
  BIC(sreg, bw, dreg, oset, 0, 0, DM, RB, RB.read(sreg), DM.read(oset));
}

//!Instruction bic_32isrc behavior method.
void ac_behavior( bic_32isrc ){
  mode = _32isrc;
	if (sreg != 2) // then whe are not in the absolute mode for source
    oset = (uint16_t)(oset + RB.read(sreg));
  BIC(sreg, bw, dreg, oset, 0, 0, DM, RB, DM.read(oset), RB.read(dreg));
}

//!Instruction bic_32imm behavior method.
void ac_behavior( bic_32imm ){
  mode = _32imm;
  BIC(sreg, bw, dreg, oset, 0, 0, DM, RB, oset, RB.read(dreg));
}

//!Instruction bic_32iaim behavior method.
void ac_behavior( bic_32iaim ){
  mode = _32iaim;
	if (dreg != 2)
     oset = (uint16_t)(oset + RB.read(dreg));
  BIC(sreg, bw, dreg, oset, 0, 0, DM, RB, DM.read(RB.read(sreg)), DM.read(oset));
}

//!Instruction bic_32irm behavior method.
void ac_behavior( bic_32irm ){
  mode = _32irm;
	if (dreg != 2)
    oset = (uint16_t)(oset + RB.read(dreg));
  BIC(sreg, bw, dreg, oset, 0, 0, DM, RB, DM.read(RB.read(sreg)), DM.read(oset));
}

//!Instruction bic_48idm behavior method.
void ac_behavior( bic_48idm ){
  mode = _48idm;
  if ((sreg != SR && dreg != SR)) {// then we are using indexed mode
    if (constant.mode) 
      odst = (uint16_t)(osrc + RB.read(dreg));
    else {
      odst = (uint16_t)(odst + RB.read(dreg));
      osrc = (uint16_t)(osrc + RB.read(sreg));
    }
  }
  
  if (constant.mode && dreg == SR)
    odst = (uint16_t)(osrc);
  
  BIC(sreg, bw, dreg, 0, osrc, odst, DM, RB, DM.read(osrc), DM.read(odst));
}

//!Instruction bic_48imm behavior method.
void ac_behavior( bic_48imm ){
  mode = _48imm;
	if (dreg != 2)
    odst = (uint16_t)(odst + RB.read(dreg));
  BIC(sreg, bw, dreg, 0, osrc, odst, DM, RB, osrc, DM.read(odst));
}
//@}

/**
 * 
 * @defgroup BIS BIS instruction 
 * 
 * @brief group for all addressing modes
 * @{ 
 */
//****************** BIS ************************
//!Instruction bis_16rm behavior method.
void ac_behavior( bis_16rm ){
  mode = _16rm;
  BIS(sreg, bw, dreg, 0, 0, 0, DM, RB, RB.read(sreg), RB.read(dreg));
}

//!Instruction bis_16irm behavior method.
void ac_behavior( bis_16irm ){
  mode = _16irm;
  BIS(sreg, bw, dreg, 0, 0, 0, DM, RB, DM.read(RB.read(sreg)), RB.read(dreg));
}

//!Instruction bis_16iaim behavior method.
void ac_behavior( bis_16iaim ){
  mode = _16iaim;
  BIS(sreg, bw, dreg, 0, 0, 0, DM, RB, DM.read(RB.read(sreg)), RB.read(dreg));
}

//!Instruction bis_32idst behavior method.
void ac_behavior( bis_32idst ){
  mode = _32idst;
		if (dreg != 2)
    oset = (uint16_t)(oset + RB.read(dreg));
  BIS(sreg, bw, dreg, oset, 0, 0, DM, RB, RB.read(sreg), DM.read(oset));
}

//!Instruction bis_32isrc behavior method.
void ac_behavior( bis_32isrc ){
  mode = _32isrc;
	if (sreg != 2) // then whe are not in the absolute mode for source
    oset = (uint16_t)(oset + RB.read(sreg));
  BIS(sreg, bw, dreg, oset, 0, 0, DM, RB, DM.read(oset), RB.read(dreg));
}

//!Instruction bis_32imm behavior method.
void ac_behavior( bis_32imm ){
  mode = _32imm;
  BIS(sreg, bw, dreg, oset, 0, 0, DM, RB, oset, RB.read(dreg));
}

//!Instruction bis_32iaim behavior method.
void ac_behavior( bis_32iaim ){
  mode = _32iaim;
	if (dreg != 2)
     oset = (uint16_t)(oset + RB.read(dreg));
  BIS(sreg, bw, dreg, oset, 0, 0, DM, RB, DM.read(RB.read(sreg)), DM.read(oset));
}

//!Instruction bis_32irm behavior method.
void ac_behavior( bis_32irm ){
  mode = _32irm;
	if (dreg != 2)
    oset = (uint16_t)(oset + RB.read(dreg));
  BIS(sreg, bw, dreg, oset, 0, 0, DM, RB, DM.read(RB.read(sreg)), DM.read(oset));
}

//!Instruction bis_48idm behavior method.
void ac_behavior( bis_48idm ){
  mode = _48idm;
  if ((sreg != SR && dreg != SR)) {// then we are using indexed mode
    if (constant.mode) 
      odst = (uint16_t)(osrc + RB.read(dreg));
    else {
      odst = (uint16_t)(odst + RB.read(dreg));
      osrc = (uint16_t)(osrc + RB.read(sreg));
    }
  }

  if (constant.mode && dreg == SR)
    odst = (uint16_t)(osrc);

  BIS(sreg, bw, dreg, 0, osrc, odst, DM, RB, DM.read(osrc), DM.read(odst));
}

//!Instruction bis_48imm behavior method.
void ac_behavior( bis_48imm ){
  mode = _48imm;
	if (dreg != 2)
    odst = (uint16_t)(odst + RB.read(dreg));
  BIS(sreg, bw, dreg, 0, osrc, odst, DM, RB, osrc, DM.read(odst));
}
//@}

/**
 * 
 * @defgroup BIT BIT instruction 
 * 
 * @brief group for all addressing modes
 * @{ 
 */
//****************** BIT ************************
//!Instruction bit_16rm behavior method.
void ac_behavior( bit_16rm ){
  mode = _16rm;
  BIT(sreg, bw, dreg, 0, 0, 0, DM, RB, RB.read(sreg), RB.read(dreg));
}

//!Instruction bit_16irm behavior method.
void ac_behavior( bit_16irm ){
  mode = _16irm;
  BIT(sreg, bw, dreg, 0, 0, 0, DM, RB, DM.read(RB.read(sreg)), RB.read(dreg));
}

//!Instruction bit_16iaim behavior method.
void ac_behavior( bit_16iaim ){
  mode = _16iaim;
  BIT(sreg, bw, dreg, 0, 0, 0, DM, RB, DM.read(RB.read(sreg)), RB.read(dreg));
}

//!Instruction bit_32idst behavior method.
void ac_behavior( bit_32idst ){
  mode = _32idst;
		if (dreg != 2)
    oset = (uint16_t)(oset + RB.read(dreg));
  BIT(sreg, bw, dreg, oset, 0, 0, DM, RB, RB.read(sreg), DM.read(oset));
}

//!Instruction bit_32isrc behavior method.
void ac_behavior( bit_32isrc ){
  mode = _32isrc;
	if (sreg != 2) // then whe are not in the absolute mode for source
    oset = (uint16_t)(oset + RB.read(sreg));
  BIT(sreg, bw, dreg, oset, 0, 0, DM, RB, DM.read(oset), RB.read(dreg));
}

//!Instruction bit_32imm behavior method.
void ac_behavior( bit_32imm ){
  mode = _32imm;
  BIT(sreg, bw, dreg, oset, 0, 0, DM, RB, oset, RB.read(dreg));
}

//!Instruction bit_32iaim behavior method.
void ac_behavior( bit_32iaim ){
  mode = _32iaim;
	if (dreg != 2)
     oset = (uint16_t)(oset + RB.read(dreg));
  BIT(sreg, bw, dreg, oset, 0, 0, DM, RB, DM.read(RB.read(sreg)), DM.read(oset));
}

//!Instruction bit_32irm behavior method.
void ac_behavior( bit_32irm ){
  mode = _32irm;
	if (dreg != 2)
    oset = (uint16_t)(oset + RB.read(dreg));
  BIT(sreg, bw, dreg, oset, 0, 0, DM, RB, DM.read(RB.read(sreg)), DM.read(oset));
}

//!Instruction bit_48idm behavior method.
void ac_behavior( bit_48idm ){
  mode = _48idm;
  if ((sreg != SR && dreg != SR)) {// then we are using indexed mode
    if (constant.mode) 
      odst = (uint16_t)(osrc + RB.read(dreg));
    else {
      odst = (uint16_t)(odst + RB.read(dreg));
      osrc = (uint16_t)(osrc + RB.read(sreg));
    }    
  }

  if (constant.mode && dreg == SR)
    odst = (uint16_t)(osrc);
  
  BIT(sreg, bw, dreg, 0, osrc, odst, DM, RB, DM.read(osrc), DM.read(odst));
}

//!Instruction bit_48imm behavior method.
void ac_behavior( bit_48imm ){
  mode = _48imm;
	if (dreg != 2)
    odst = (uint16_t)(odst + RB.read(dreg));
  BIT(sreg, bw, dreg, 0, osrc, odst, DM, RB, osrc, DM.read(odst));
}
//@}

/**
 * 
 * @defgroup CMP CMP instruction 
 * 
 * @brief group for all addressing modes
 * @{ 
 */
//****************** CMP ************************
//!Instruction cmp_16rm behavior method.
void ac_behavior( cmp_16rm ){
  mode = _16rm;
  CMP(sreg, bw, dreg, 0, 0, 0, DM, RB, RB.read(sreg), RB.read(dreg));
}

//!Instruction cmp_16irm behavior method.
void ac_behavior( cmp_16irm ){
  mode = _16irm;
  CMP(sreg, bw, dreg, 0, 0, 0, DM, RB, DM.read(RB.read(sreg)), RB.read(dreg));
}

//!Instruction cmp_16iaim behavior method.
void ac_behavior( cmp_16iaim ){
  mode = _16iaim;
  CMP(sreg, bw, dreg, 0, 0, 0, DM, RB, DM.read(RB.read(sreg)), RB.read(dreg));
}

//!Instruction cmp_32idst behavior method.
void ac_behavior( cmp_32idst ){
  mode = _32idst;
		if (dreg != 2)
    oset = (uint16_t)(oset + RB.read(dreg));
  CMP(sreg, bw, dreg, oset, 0, 0, DM, RB, RB.read(sreg), DM.read(oset));
}

//!Instruction cmp_32isrc behavior method.
void ac_behavior( cmp_32isrc ){
  mode = _32isrc;
	if (sreg != 2) // then whe are not in the absolute mode for source
    oset = (uint16_t)(oset + RB.read(sreg));
  CMP(sreg, bw, dreg, oset, 0, 0, DM, RB, DM.read(oset), RB.read(dreg));
}

//!Instruction cmp_32imm behavior method.
void ac_behavior( cmp_32imm ){
  mode = _32imm;
  CMP(sreg, bw, dreg, oset, 0, 0, DM, RB, oset, RB.read(dreg));
}

//!Instruction cmp_32iaim behavior method.
void ac_behavior( cmp_32iaim ){
  mode = _32iaim;
	if (dreg != 2)
     oset = (uint16_t)(oset + RB.read(dreg));
  CMP(sreg, bw, dreg, oset, 0, 0, DM, RB, DM.read(RB.read(sreg)), DM.read(oset));
}

//!Instruction cmp_32irm behavior method.
void ac_behavior( cmp_32irm ){
  mode = _32irm;
	if (dreg != 2)
    oset = (uint16_t)(oset + RB.read(dreg));
  CMP(sreg, bw, dreg, oset, 0, 0, DM, RB, DM.read(RB.read(sreg)), DM.read(oset));
}

//!Instruction cmp_48idm behavior method.
void ac_behavior( cmp_48idm ){
  mode = _48idm;
  if ((sreg != SR && dreg != SR)) {// then we are using indexed mode
    if (constant.mode) 
      odst = (uint16_t)(osrc + RB.read(dreg));
    else {
      odst = (uint16_t)(odst + RB.read(dreg));
      osrc = (uint16_t)(osrc + RB.read(sreg));
    }    
  }

  if (constant.mode && dreg == SR)
    odst = (uint16_t)(osrc);

  CMP(sreg, bw, dreg, 0, osrc, odst, DM, RB, DM.read(osrc), DM.read(odst));
}

//!Instruction cmp_48imm behavior method.
void ac_behavior( cmp_48imm ){
  mode = _48imm;
	if (dreg != 2)
    odst = (uint16_t)(odst + RB.read(dreg));
  CMP(sreg, bw, dreg, 0, osrc, odst, DM, RB, osrc, DM.read(odst));
}
//@}

/**
 * 
 * @defgroup DADD DADD instruction 
 * 
 * @brief group for all addressing modes
 * @{ 
 */
//****************** DADD ************************
//!Instruction dadd_16rm behavior method.
void ac_behavior( dadd_16rm ){
  mode = _16rm;
  DADD(sreg, bw, dreg, 0, 0, 0, DM, RB, RB.read(sreg), RB.read(dreg));
}

//!Instruction dadd_16irm behavior method.
void ac_behavior( dadd_16irm ){
  mode = _16irm;
  DADD(sreg, bw, dreg, 0, 0, 0, DM, RB, DM.read(RB.read(sreg)), RB.read(dreg));
}

//!Instruction dadd_16iaim behavior method.
void ac_behavior( dadd_16iaim ){
  mode = _16iaim;
  DADD(sreg, bw, dreg, 0, 0, 0, DM, RB, DM.read(RB.read(sreg)), RB.read(dreg));
}

//!Instruction dadd_32idst behavior method.
void ac_behavior( dadd_32idst ){
  mode = _32idst;
		if (dreg != 2)
    oset = (uint16_t)(oset + RB.read(dreg));
  DADD(sreg, bw, dreg, oset, 0, 0, DM, RB, RB.read(sreg), DM.read(oset));
}

//!Instruction dadd_32isrc behavior method.
void ac_behavior( dadd_32isrc ){
  mode = _32isrc;
	if (sreg != 2) // then whe are not in the absolute mode for source
    oset = (uint16_t)(oset + RB.read(sreg));
  DADD(sreg, bw, dreg, oset, 0, 0, DM, RB, DM.read(oset), RB.read(dreg));
}

//!Instruction dadd_32imm behavior method.
void ac_behavior( dadd_32imm ){
  mode = _32imm;
  DADD(sreg, bw, dreg, oset, 0, 0, DM, RB, oset, RB.read(dreg));
}

//!Instruction dadd_32iaim behavior method.
void ac_behavior( dadd_32iaim ){
  mode = _32iaim;
	if (dreg != 2)
     oset = (uint16_t)(oset + RB.read(dreg));
  DADD(sreg, bw, dreg, oset, 0, 0, DM, RB, DM.read(RB.read(sreg)), DM.read(oset));
}

//!Instruction dadd_32irm behavior method.
void ac_behavior( dadd_32irm ){
  mode = _32irm;
	if (dreg != 2)
    oset = (uint16_t)(oset + RB.read(dreg));
  DADD(sreg, bw, dreg, oset, 0, 0, DM, RB, DM.read(RB.read(sreg)), DM.read(oset));
}

//!Instruction dadd_48idm behavior method.
void ac_behavior( dadd_48idm ){
  mode = _48idm;
  if ((sreg != SR && dreg != SR)) {// then we are using indexed mode
    if (constant.mode) 
      odst = (uint16_t)(osrc + RB.read(dreg));
    else {
      odst = (uint16_t)(odst + RB.read(dreg));
      osrc = (uint16_t)(osrc + RB.read(sreg));
    }
  }

  if (constant.mode && dreg == SR)
    odst = (uint16_t)(osrc);

  DADD(sreg, bw, dreg, 0, osrc, odst, DM, RB, DM.read(osrc), DM.read(odst));
}

//!Instruction dadd_48imm behavior method.
void ac_behavior( dadd_48imm ){
  mode = _48imm;
	if (dreg != 2)
    odst = (uint16_t)(odst + RB.read(dreg));
  DADD(sreg, bw, dreg, 0, osrc, odst, DM, RB, osrc, DM.read(odst));
}
//@}

/**
 * 
 * @defgroup SUB SUB instruction 
 * 
 * @brief group for all addressing modes
 * @{ 
 */
//****************** SUB ************************
//!Instruction sub_16rm behavior method.
void ac_behavior( sub_16rm ){
  mode = _16rm;
  SUB(sreg, bw, dreg, 0, 0, 0, DM, RB, RB.read(sreg), RB.read(dreg));
}

//!Instruction sub_16irm behavior method.
void ac_behavior( sub_16irm ){
  mode = _16irm;
  SUB(sreg, bw, dreg, 0, 0, 0, DM, RB, DM.read(RB.read(sreg)), RB.read(dreg));
}

//!Instruction sub_16iaim behavior method.
void ac_behavior( sub_16iaim ){
  mode = _16iaim;
  SUB(sreg, bw, dreg, 0, 0, 0, DM, RB, DM.read(RB.read(sreg)), RB.read(dreg));
}

//!Instruction sub_32idst behavior method.
void ac_behavior( sub_32idst ){
  mode = _32idst;
		if (dreg != 2)
    oset = (uint16_t)(oset + RB.read(dreg));
  SUB(sreg, bw, dreg, oset, 0, 0, DM, RB, RB.read(sreg), DM.read(oset));
}

//!Instruction sub_32isrc behavior method.
void ac_behavior( sub_32isrc ){
  mode = _32isrc;
	if (sreg != 2) // then whe are not in the absolute mode for source
    oset = (uint16_t)(oset + RB.read(sreg));
  SUB(sreg, bw, dreg, oset, 0, 0, DM, RB, DM.read(oset), RB.read(dreg));
}

//!Instruction sub_32imm behavior method.
void ac_behavior( sub_32imm ){
  mode = _32imm;
  SUB(sreg, bw, dreg, oset, 0, 0, DM, RB, oset, RB.read(dreg));
}

//!Instruction sub_32iaim behavior method.
void ac_behavior( sub_32iaim ){
  mode = _32iaim;
	if (dreg != 2)
     oset = (uint16_t)(oset + RB.read(dreg));
  SUB(sreg, bw, dreg, oset, 0, 0, DM, RB, DM.read(RB.read(sreg)), DM.read(oset));
}

//!Instruction sub_32irm behavior method.
void ac_behavior( sub_32irm ){
  mode = _32irm;
	if (dreg != 2)
    oset = (uint16_t)(oset + RB.read(dreg));
  SUB(sreg, bw, dreg, oset, 0, 0, DM, RB, DM.read(RB.read(sreg)), DM.read(oset));
}

//!Instruction sub_48idm behavior method.
void ac_behavior( sub_48idm ){
  mode = _48idm;
  if ((sreg != SR && dreg != SR)) {// then we are using indexed mode
    if (constant.mode) 
      odst = (uint16_t)(osrc + RB.read(dreg));
    else {
      odst = (uint16_t)(odst + RB.read(dreg));
      osrc = (uint16_t)(osrc + RB.read(sreg));
    }
  }

  if (constant.mode && dreg == SR)
    odst = (uint16_t)(osrc);

  SUB(sreg, bw, dreg, 0, osrc, odst, DM, RB, DM.read(osrc), DM.read(odst));
}

//!Instruction sub_48imm behavior method.
void ac_behavior( sub_48imm ){
  mode = _48imm;
	if (dreg != 2)
    odst = (uint16_t)(odst + RB.read(dreg));
  SUB(sreg, bw, dreg, 0, osrc, odst, DM, RB, osrc, DM.read(odst));
}
//@}

/**
 * 
 * @defgroup SUBC SUBC instruction 
 * 
 * @brief group for all addressing modes
 * @{ 
 */
//****************** SUBC ************************
//!Instruction subc_16rm behavior method.
void ac_behavior( subc_16rm ){
  mode = _16rm;
  SUBC(sreg, bw, dreg, 0, 0, 0, DM, RB, RB.read(sreg), RB.read(dreg));
}

//!Instruction subc_16irm behavior method.
void ac_behavior( subc_16irm ){
  mode = _16irm;
  SUBC(sreg, bw, dreg, 0, 0, 0, DM, RB, DM.read(RB.read(sreg)), RB.read(dreg));
}

//!Instruction subc_16iaim behavior method.
void ac_behavior( subc_16iaim ){
  mode = _16iaim;
  SUBC(sreg, bw, dreg, 0, 0, 0, DM, RB, DM.read(RB.read(sreg)), RB.read(dreg));
}

//!Instruction subc_32idst behavior method.
void ac_behavior( subc_32idst ){
  mode = _32idst;
		if (dreg != 2)
    oset = (uint16_t)(oset + RB.read(dreg));
  SUBC(sreg, bw, dreg, oset, 0, 0, DM, RB, RB.read(sreg), DM.read(oset));
}

//!Instruction subc_32isrc behavior method.
void ac_behavior( subc_32isrc ){
  mode = _32isrc;
	if (sreg != 2) // then whe are not in the absolute mode for source
    oset = (uint16_t)(oset + RB.read(sreg));
  SUBC(sreg, bw, dreg, oset, 0, 0, DM, RB, DM.read(oset), RB.read(dreg));
}

//!Instruction subc_32imm behavior method.
void ac_behavior( subc_32imm ){
  mode = _32imm;
  SUBC(sreg, bw, dreg, oset, 0, 0, DM, RB, oset, RB.read(dreg));
}

//!Instruction subc_32iaim behavior method.
void ac_behavior( subc_32iaim ){
  mode = _32iaim;
	if (dreg != 2)
     oset = (uint16_t)(oset + RB.read(dreg));
  SUBC(sreg, bw, dreg, oset, 0, 0, DM, RB, DM.read(RB.read(sreg)), DM.read(oset));
}

//!Instruction subc_32irm behavior method.
void ac_behavior( subc_32irm ){
  mode = _32irm;
	if (dreg != 2)
    oset = (uint16_t)(oset + RB.read(dreg));
  SUBC(sreg, bw, dreg, oset, 0, 0, DM, RB, DM.read(RB.read(sreg)), DM.read(oset));
}

//!Instruction subc_48idm behavior method.
void ac_behavior( subc_48idm ){
  mode = _48idm;
  if ((sreg != SR && dreg != SR)) {// then we are using indexed mode
    if (constant.mode) 
      odst = (uint16_t)(osrc + RB.read(dreg));
    else {
      odst = (uint16_t)(odst + RB.read(dreg));
      osrc = (uint16_t)(osrc + RB.read(sreg));
    }
  }
  
  if (constant.mode && dreg == SR)
    odst = (uint16_t)(osrc);

  SUBC(sreg, bw, dreg, 0, osrc, odst, DM, RB, DM.read(osrc), DM.read(odst));
}

//!Instruction subc_48imm behavior method.
void ac_behavior( subc_48imm ){
  mode = _48imm;
	if (dreg != 2)
    odst = (uint16_t)(odst + RB.read(dreg));
  SUBC(sreg, bw, dreg, 0, osrc, odst, DM, RB, osrc, DM.read(odst));
}
//@}

/**
 * 
 * @defgroup XOR XOR instruction 
 * 
 * @brief group for all addressing modes
 * @{ 
 */
//****************** XOR ************************
//!Instruction xor_16rm behavior method.
void ac_behavior( xor_16rm ){
  mode = _16rm;
  XOR(sreg, bw, dreg, 0, 0, 0, DM, RB, RB.read(sreg), RB.read(dreg));
}

//!Instruction xor_16irm behavior method.
void ac_behavior( xor_16irm ){
  mode = _16irm;
  XOR(sreg, bw, dreg, 0, 0, 0, DM, RB, DM.read(RB.read(sreg)), RB.read(dreg));
}

//!Instruction xor_16iaim behavior method.
void ac_behavior( xor_16iaim ){
  mode = _16iaim;
  XOR(sreg, bw, dreg, 0, 0, 0, DM, RB, DM.read(RB.read(sreg)), RB.read(dreg));
}

//!Instruction xor_32idst behavior method.
void ac_behavior( xor_32idst ){
  mode = _32idst;
		if (dreg != 2)
    oset = (uint16_t)(oset + RB.read(dreg));
  XOR(sreg, bw, dreg, oset, 0, 0, DM, RB, RB.read(sreg), DM.read(oset));
}

//!Instruction xor_32isrc behavior method.
void ac_behavior( xor_32isrc ){
  mode = _32isrc;
	if (sreg != 2) // then whe are not in the absolute mode for source
    oset = (uint16_t)(oset + RB.read(sreg));
  XOR(sreg, bw, dreg, oset, 0, 0, DM, RB, DM.read(oset), RB.read(dreg));
}

//!Instruction xor_32imm behavior method.
void ac_behavior( xor_32imm ){
  mode = _32imm;
  XOR(sreg, bw, dreg, oset, 0, 0, DM, RB, oset, RB.read(dreg));
}

//!Instruction xor_32iaim behavior method.
void ac_behavior( xor_32iaim ){
  mode = _32iaim;
  if (dreg != 2) 
    oset = (uint16_t)(oset + RB.read(dreg));
  XOR(sreg, bw, dreg, oset, 0, 0, DM, RB, DM.read(RB.read(sreg)), DM.read(oset));
}

//!Instruction xor_32irm behavior method.
void ac_behavior( xor_32irm ){
  mode = _32irm;
	if (dreg != 2)
    oset = (uint16_t)(oset + RB.read(dreg));
  XOR(sreg, bw, dreg, oset, 0, 0, DM, RB, DM.read(RB.read(sreg)), DM.read(oset));
}

//!Instruction xor_48idm behavior method.
void ac_behavior( xor_48idm ){
  mode = _48idm;
  if ((sreg != SR && dreg != SR)) {// then we are using indexed mode
    if (constant.mode) 
      odst = (uint16_t)(osrc + RB.read(dreg));
    else {
      odst = (uint16_t)(odst + RB.read(dreg));
      osrc = (uint16_t)(osrc + RB.read(sreg));
    }
  }

  if (constant.mode && dreg == SR)
    odst = (uint16_t)(osrc);

  XOR(sreg, bw, dreg, 0, osrc, odst, DM, RB, DM.read(osrc), DM.read(odst));
}

//!Instruction xor_48imm behavior method.
void ac_behavior( xor_48imm ){
  mode = _48imm;
	if (dreg != 2)
    odst = (uint16_t)(odst + RB.read(dreg));
  XOR(sreg, bw, dreg, 0, osrc, odst, DM, RB, osrc, DM.read(odst));
}
//@}
//@}
//*****************************************************
// Single Operand instructions
//*****************************************************

/**
 * 
 * @defgroup SINGLE SINGLE operand instruction 
 * 
 * @brief All SINGLE operand instructions
 * @{ 
 */

/**
 * 
 * @defgroup RRC RRC instruction 
 * 
 * @brief group for all addressing modes
 * @{ 
 */
//**********************RRC**********************
//!Instruction rrc_16rm behavior method.
void ac_behavior( rrc_16rm ){
  mode = _16rm;
  RRC(bw, sreg, 0, DM, RB, RB.read(sreg));
}

//!Instruction rrc_16irm behavior method.
void ac_behavior( rrc_16irm ){
  // trick to save on memory
  // simplification 
  // here indexed register mode is used to 
  // save directly into memory using write_back method 
  mode = _32irm;
  RRC(bw, sreg, RB.read(sreg), DM, RB, DM.read(RB.read(sreg)));
}

//!Instruction rrc_16iaim behavior method.
void ac_behavior( rrc_16iaim ){
  mode = _16iaim;
  RRC(bw, sreg, 0, DM, RB, RB.read(sreg));
}

//!Instruction rrc_32sm behavior method.
void ac_behavior( rrc_32sm ){
  mode = _32irm;
  RRC(bw, sreg, oset, DM, RB, DM.read(RB.read(sreg)));
}

//!Instruction rrc_32am behavior method.
void ac_behavior( rrc_32am ){
  mode = _32irm;
  RRC(bw, sreg, oset, DM, RB, DM.read(RB.read(sreg)));
}

//!Instruction rrc_32imm behavior method.
void ac_behavior( rrc_32imm ){
  printf("Unpredictable program operation");
  printf("Annulling instruction execution");
  ac_annul();  
}

//!Instruction rrc_32im behavior method.
void ac_behavior( rrc_32im ){
  mode = _32irm;
  RRC(bw, sreg, oset, DM, RB, DM.read(RB.read(sreg)));
}
//@}

/**
 * 
 * @defgroup SWPB SWPB instruction 
 * 
 * @brief group for all addressing modes
 * @{ 
 */
//**********************SWPB**********************
//!Instruction swpb_16rm behavior method.
void ac_behavior( swpb_16rm ){
  mode = _16rm;
  SWPB(bw, sreg, 0, DM, RB, RB.read(sreg));
}

//!Instruction swpb_16irm behavior method.
void ac_behavior( swpb_16irm ){
  // trick to save on memory
  // simplification 
  // here indexed register mode is used to 
  // save directly into memory using write_back method 
  mode = _32irm;
  SWPB(bw, sreg, RB.read(sreg), DM, RB, DM.read(RB.read(sreg)));
}

//!Instruction swpb_16iaim behavior method.
void ac_behavior( swpb_16iaim ){
  mode = _16iaim;
  SWPB(bw, sreg, 0, DM, RB, RB.read(sreg));
}

//!Instruction swpb_32sm behavior method.
void ac_behavior( swpb_32sm ){
  mode = _32irm;
  SWPB(bw, sreg, oset, DM, RB, DM.read(RB.read(sreg)));
}

//!Instruction swpb_32am behavior method.
void ac_behavior( swpb_32am ){
  mode = _32irm;
  SWPB(bw, sreg, oset, DM, RB, DM.read(RB.read(sreg)));
}

//!Instruction swpb_32imm behavior method.
void ac_behavior( swpb_32imm ){
  printf("Unpredictable program operation");
  printf("Annulling instruction execution");
  ac_annul();  
}

//!Instruction swpb_32im behavior method.
void ac_behavior( swpb_32im ){
  mode = _32irm;
  SWPB(bw, sreg, oset, DM, RB, DM.read(RB.read(sreg)));
}
//@}

/**
 * 
 * @defgroup RRA RRA instruction 
 * 
 * @brief group for all addressing modes
 * @{ 
 */
//**********************RRA**********************
//!Instruction rra_16rm behavior method.
void ac_behavior( rra_16rm ){
  mode = _16rm;
  RRA(bw, sreg, 0, DM, RB, RB.read(sreg));
}

//!Instruction rra_16irm behavior method.
void ac_behavior( rra_16irm ){
  // trick to save on memory
  // simplification 
  // here indexed register mode is used to 
  // save directly into memory using write_back method 
  mode = _32irm;
  RRA(bw, sreg, RB.read(sreg), DM, RB, DM.read(RB.read(sreg)));
}

//!Instruction rra_16iaim behavior method.
void ac_behavior( rra_16iaim ){
  mode = _16iaim;
  RRA(bw, sreg, 0, DM, RB, RB.read(sreg));
}

//!Instruction rra_32sm behavior method.
void ac_behavior( rra_32sm ){
  mode = _32irm;
  RRA(bw, sreg, oset, DM, RB, DM.read(RB.read(sreg)));
}

//!Instruction rra_32am behavior method.
void ac_behavior( rra_32am ){
  mode = _32irm;
  RRA(bw, sreg, oset, DM, RB, DM.read(RB.read(sreg)));
}

//!Instruction rra_32imm behavior method.
void ac_behavior( rra_32imm ){
  printf("Unpredictable program operation");
  printf("Annulling instruction execution");
  ac_annul();  
}

//!Instruction rra_32im behavior method.
void ac_behavior( rra_32im ){
  mode = _32irm;
  RRA(bw, sreg, oset, DM, RB, DM.read(RB.read(sreg)));
}
//@}

/**
 * 
 * @defgroup SXT SXT instruction 
 * 
 * @brief group for all addressing modes
 * @{ 
 */
//**********************SXT**********************
//!Instruction sxt_16rm behavior method.
void ac_behavior( sxt_16rm ){
  mode = _16rm;
  SXT(bw, sreg, 0, DM, RB, RB.read(sreg));
}

//!Instruction sxt_16irm behavior method.
void ac_behavior( sxt_16irm ){
  // trick to save on memory
  // simplification 
  // here indexed register mode is used to 
  // save directly into memory using write_back method
  // RB.read(sreg) -> oset
  mode = _32irm;
  SXT(bw, sreg, RB.read(sreg), DM, RB, DM.read(RB.read(sreg)));
}

//!Instruction sxt_16iaim behavior method.
void ac_behavior( sxt_16iaim ){
  mode = _16iaim;
  SXT(bw, sreg, 0, DM, RB, RB.read(sreg));
}

//!Instruction sxt_32sm behavior method.
void ac_behavior( sxt_32sm ){
  mode = _32irm;
  SXT(bw, sreg, oset, DM, RB, DM.read(RB.read(sreg)));
}

//!Instruction sxt_32am behavior method.
void ac_behavior( sxt_32am ){
  mode = _32irm;
  SXT(bw, sreg, oset, DM, RB, DM.read(RB.read(sreg)));
}

//!Instruction sxt_32imm behavior method.
void ac_behavior( sxt_32imm ){
  printf("Unpredictable program operation");
  printf("Annulling instruction execution");
  ac_annul();  
}

//!Instruction sxt_32im behavior method.
void ac_behavior( sxt_32im ){
  mode = _32irm;
  if (sreg != 2) 
    oset = (uint16_t)(oset + RB.read(sreg));
  SXT(bw, sreg, oset, DM, RB, DM.read(oset));
}
//@}

/**
 * 
 * @defgroup PUSH PUSH instruction 
 * 
 * @brief group for all addressing modes
 * @{ 
 */
//**********************PUSH**********************
//!Instruction push_16rm behavior method.
void ac_behavior( push_16rm ){
  mode = _16rm;
  PUSH(bw, sreg, 0, DM, RB);
}

//!Instruction push_16irm behavior method.
void ac_behavior( push_16irm ){
  mode = _16irm;
  PUSH(bw, sreg, 0, DM, RB);
}

//!Instruction push_16iaim behavior method.
void ac_behavior( push_16iaim ){
  mode = _16iaim;
  PUSH(bw, sreg, 0, DM, RB);
}

//!Instruction push_32sm behavior method.
void ac_behavior( push_32sm ){
  mode = _32irm;
  if (sreg != 2) 
    oset = (uint16_t)(oset + RB.read(sreg));
  PUSH(bw, sreg, oset, DM, RB);
}

//!Instruction push_32am behavior method.
void ac_behavior( push_32am ){
  mode = _32irm;
  if (sreg != 2) 
    oset = (uint16_t)(oset + RB.read(sreg));
  PUSH(bw, sreg, oset, DM, RB);
}

//!Instruction push_32imm behavior method.
void ac_behavior( push_32imm ){
  mode = _32imm;
  if (constant.mode) {
    oset = constant.value;
    constant.mode = false;
  }
  PUSH(bw, sreg, oset, DM, RB);
}

//!Instruction push_32im behavior method.
void ac_behavior( push_32im ){
  mode = _32irm;
  if (sreg != 2) 
    oset = (uint16_t)(oset + RB.read(sreg));
  PUSH(bw, sreg, oset, DM, RB);
}
//@}

/**
 * 
 * @defgroup CALL CALL instruction 
 * 
 * @brief group for all addressing modes
 * @{ 
 */
//**********************CALL**********************
//!Instruction call_16rm behavior method.
void ac_behavior( call_16rm ){
  mode = _16rm;
  CALL(bw, sreg, 0, DM, RB, ac_pc);
}

//!Instruction call_16irm behavior method.
void ac_behavior( call_16irm ){
  // trick to save on memory
  // simplification 
  // here indexed register mode is used to 
  // save directly into memory using write_back method 
  mode = _16irm;
  CALL(bw, sreg, 0, DM, RB, ac_pc);
}

//!Instruction call_16iaim behavior method.
void ac_behavior( call_16iaim ){
  mode = _16iaim;
  CALL(bw, sreg, 0, DM, RB, ac_pc);
}

//!Instruction call_32sm behavior method.
void ac_behavior( call_32sm ){
  mode = _32irm;
  CALL(bw, sreg, oset, DM, RB, ac_pc);
}

//!Instruction call_32am behavior method.
void ac_behavior( call_32am ){
  mode = _32irm;
  CALL(bw, sreg, oset, DM, RB, ac_pc);
}

/**
 * @todo fix to all the instructions
 * _32imm has to match all the instructions
 * 
 */
//!Instruction call_32imm behavior method.
void ac_behavior( call_32imm ){
  mode = _32imm;
  CALL(bw, sreg, oset, DM, RB, ac_pc);
}

//!Instruction call_32im behavior method.
void ac_behavior( call_32im ){
  mode = _32irm;
  CALL(bw, sreg, oset, DM, RB, ac_pc);
}
//@}

/**
 * 
 * @defgroup RETI RETI instruction 
 * 
 * @brief group for all addressing modes
 * @{ 
 */
//**********************RETI**********************
//!Instruction reti behavior method.
void ac_behavior( reti ){
  RETI(bw, sreg, 0, DM, RB, ac_pc);
}
//@}
//@}
/**
 * 
 * @defgroup JUMP JUMP instruction 
 * 
 * @brief ALL JUMP instructions
 * @{ 
 */
//*****************************************************
//  Jump Instructions
//*****************************************************

//!Instruction jne behavior method.
void ac_behavior( jne ){
  // behavior (PC is incremented)
  int label = RB.read(PC) + offset * 2;
  if (!flags.Z) {
    RB.write(PC, label);
    ac_pc = label;
  }
}


//!Instruction jeq behavior method.
void ac_behavior( jeq ){
  // behavior (PC is incremented)
  int label = RB.read(PC) + offset * 2;
  if (flags.Z) {
    RB.write(PC, label);
    ac_pc = label;
  }
}

//!Instruction jnc behavior method.
void ac_behavior( jnc ){
  // behavior (PC is incremented)
  int label = RB.read(PC) + offset * 2;
  if (!flags.C) {
    RB.write(PC, label);
    ac_pc = label;
  }
}

//!Instruction jc behavior method.
void ac_behavior( jc ){
  // behavior (PC is incremented)
  int label = RB.read(PC) + offset * 2;
  if (flags.C) {
    RB.write(PC, label);
    ac_pc = label;
  }
}

//!Instruction jn behavior method.
void ac_behavior( jn ){
  // behavior (PC is incremented)
  int label = RB.read(PC) + offset * 2;
  if (flags.N) {
    RB.write(PC, label);
    ac_pc = label;
  }
}

//!Instruction jge behavior method.
void ac_behavior( jge ){
  // behavior (PC is incremented)
  int label = RB.read(PC) + offset * 2;
  if ( !(flags.N xor flags.V)) {
    RB.write(PC, label);
    ac_pc = label;
  }
}

//!Instruction jl behavior method.
void ac_behavior( jl ){
  // behavior (PC is incremented)
  int label = RB.read(PC) + offset * 2;
  if ( (flags.N xor flags.V)) {
    RB.write(PC, label);
    ac_pc = label;
  }
}

//!Instruction jmp behavior method.
void ac_behavior( jmp ){
  // behavior (unconditionally)
  int label = RB.read(PC) + offset * 2;

  RB.write(PC, label);
  ac_pc = label;  
}
//@}
