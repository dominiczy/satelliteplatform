/******************************************************
 * Processor module implementation file.              *
 * This file is automatically generated by ArchC      *
 * WITHOUT WARRANTY OF ANY KIND, either express       *
 * or implied.                                        *
 * For more information on ArchC, please visit:       *
 * http://www.archc.org                               *
 *                                                    *
 * The ArchC Team                                     *
 * Computer Systems Laboratory (LSC)                  *
 * IC-UNICAMP                                         *
 * http://www.lsc.ic.unicamp.br                       *
 ******************************************************/

#include "msp430_parms.H"
#include "msp430_arch.H"
#include "msp430.H"
#include <signal.h>

#include <ac_sighandlers.H>

//! Initialization (2 arguments).
void msp430::init(int ac, char** av)
{
 extern char* appfilename;
 ac_init_opt(ac, av);
 ac_init_app(ac, av);
 APP_MEM->load(appfilename);
 time_step = period / (sc_get_default_time_unit()).to_double();
 set_args(ac_argc, ac_argv);
 isa._behavior_begin();
 cerr << "ArchC: -------------------- Starting Simulation --------------------" << endl;
 InitStat();

 signal(SIGINT, sigint_handler);
 signal(SIGTERM, sigint_handler);
 signal(SIGSEGV, sigsegv_handler);
 signal(SIGUSR1, sigusr1_handler);
#ifdef USE_GDB
 signal(SIGUSR2, sigusr2_handler);
#endif
 set_running();
 return;
}

//! Initialization (no arguments).
void msp430::init()
{
 time_step = period / (sc_get_default_time_unit()).to_double();
 set_args(ac_argc, ac_argv);
 isa._behavior_begin();
 cerr << "ArchC: -------------------- Starting Simulation --------------------" << endl;
 InitStat();

 signal(SIGINT, sigint_handler);
 signal(SIGTERM, sigint_handler);
 signal(SIGSEGV, sigsegv_handler);
 signal(SIGUSR1, sigusr1_handler);
#ifdef USE_GDB
 signal(SIGUSR2, sigusr2_handler);
#endif
 set_running();
 return;
}

//! Stop simulation (may receive exit status).
void msp430::stop(int status)
{
 cerr << "ArchC: -------------------- Simulation Finished --------------------" << endl;
 isa._behavior_end();
 ac_stop_flag = 1;
 ac_exit_status = status;
 set_stopped();
 ac_arch<msp430_parms::ac_word, msp430_parms::ac_Hword>::PrintStat();
 return;
}

void msp430::load(char* program)
{
 APP_MEM->load(program);
 return;
}

void msp430::delayed_load(char* program)
{
 has_delayed_load = true;
 delayed_load_program = new char[strlen(program)];
 strcpy(delayed_load_program, program);
 return;
}

//! PrintStat wrapper method.
void msp430::PrintStat()
{
 ac_arch<msp430_parms::ac_word, msp430_parms::ac_Hword>::PrintStat();
 return;
}

//! Verification method.
void msp430::ac_verify()
{
#ifdef AC_VERBOSE
 DM.change_dump(cerr);
 RB.change_dump(cerr);
#endif
#ifdef AC_UPDATE_LOG
 DM.reset_log();
 RB.reset_log();
#endif
 if (pipe_IF.will_stall())
 {
  ac_pc.suspend();
  ac_instr_counter--;
 }
 if (pipe_ID.will_stall())
 {
  ac_pc.suspend();
  ac_instr_counter--;
 }
 return;
}

